-- KeyGuardian Validator
-- Bu dosya Roblox'ta √ßalƒ±≈üƒ±r ve KeyGuardian Brain System ile ileti≈üim kurar

local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Validator = {}

-- Ger√ßek HWID
local HWID = game:GetService("RbxAnalyticsService"):GetClientId()

-- Configuration
local BRAIN_URL = "https://kanistay.workers.dev/keyauth" -- Cloudflare Workers URL'i
local SYSTEM_TOKEN = nil -- Bu token system.lua'dan gelecek
local SECRET_SIGNATURE = "KeyGuardian2024SecretKey" -- √ñzel imza anahtarƒ± (Workers'da da aynƒ± olmalƒ±)

-- Kriptografi Anahtarlarƒ±
local CRYPTO_KEY = "KeyGuardianCrypto2024" -- XOR ≈üifreleme anahtarƒ±

-- Executor Desteƒüi Kontrol√º
local ExecutorSupport = {
    lz4 = false,
    base64 = false,
    crypt = false,
    bit32 = false
}

-- Executor desteƒüini kontrol et
local function checkExecutorSupport()
    local supported = 0
    
    -- LZ4 kontrol√º
    if pcall(function() return lz4compress("test") end) then
        ExecutorSupport.lz4 = true
        supported = supported + 1
        print("‚úÖ LZ4 compression supported")
    else
        print("‚ùå LZ4 compression not supported")
    end
    
    -- Base64 kontrol√º
    if pcall(function() return crypt.base64encode("test") end) then
        ExecutorSupport.base64 = true
        supported = supported + 1
        print("‚úÖ Base64 encoding supported")
    else
        print("‚ùå Base64 encoding not supported")
    end
    
    -- Crypt kontrol√º
    if pcall(function() return crypt.generatekey(16) end) then
        ExecutorSupport.crypt = true
        supported = supported + 1
        print("‚úÖ Crypt functions supported")
    else
        print("‚ùå Crypt functions not supported")
    end
    
    -- Bit32 kontrol√º
    if pcall(function() return bit32.bxor(1, 2) end) then
        ExecutorSupport.bit32 = true
        supported = supported + 1
        print("‚úÖ Bit32 operations supported")
    else
        print("‚ùå Bit32 operations not supported")
    end
    
    print("üìä Executor Support Summary: " .. supported .. "/4 features supported")
    
    -- En az 1 √∂zellik desteklenmeli
    if supported == 0 then
        error("üö® No encryption features supported by executor! System cannot work securely.")
    end
    
    return supported
end

-- ƒ∞mza olu≈üturma fonksiyonu (Workers'daki ile aynƒ±)
local function generateSignature(hwid, timestamp)
    local dataToSign = hwid .. timestamp .. SECRET_SIGNATURE
    
    if ExecutorSupport.bit32 then
        -- Bit32 ile hash
        local hash = 0
        for i = 1, #dataToSign do
            local char = string.byte(dataToSign, i)
            hash = bit32.bxor(bit32.lshift(hash, 5) - hash, char)
        end
        return string.format("%08x", bit32.band(hash, 0xFFFFFFFF))
    else
        -- Basit hash (fallback)
        local hash = 0
        for i = 1, #dataToSign do
            local char = string.byte(dataToSign, i)
            hash = ((hash * 31) + char) % 0xFFFFFFFF
        end
        return string.format("%08x", hash)
    end
end

-- XOR ≈ûifreleme Fonksiyonu
local function xorEncrypt(data, key)
    local encrypted = ""
    for i = 1, #data do
        local dataByte = string.byte(data, i)
        local keyByte = string.byte(key, ((i - 1) % #key) + 1)
        
        if ExecutorSupport.bit32 then
            encrypted = encrypted .. string.char(bit32.bxor(dataByte, keyByte))
        else
            -- Basit XOR (fallback)
            encrypted = encrypted .. string.char((dataByte + keyByte) % 256)
        end
    end
    return encrypted
end

-- XOR ≈ûifre √á√∂zme Fonksiyonu
local function xorDecrypt(data, key)
    if ExecutorSupport.bit32 then
        return xorEncrypt(data, key) -- XOR simetrik
    else
        -- Basit XOR √ß√∂zme (fallback)
        local decrypted = ""
        for i = 1, #data do
            local dataByte = string.byte(data, i)
            local keyByte = string.byte(key, ((i - 1) % #key) + 1)
            decrypted = decrypted .. string.char((dataByte - keyByte + 256) % 256)
        end
        return decrypted
    end
end

-- Veri ≈ûifreleme Fonksiyonu (Executor desteƒüine g√∂re)
local function encryptData(data)
    -- 1. JSON'a √ßevir
    local jsonData = HttpService:JSONEncode(data)
    
    local processedData = jsonData
    
    -- 2. LZ4 ile sƒ±kƒ±≈ütƒ±r (eƒüer destekleniyorsa)
    if ExecutorSupport.lz4 then
        processedData = lz4compress(processedData)
        print("üîí LZ4 compression applied")
    else
        print("‚ö†Ô∏è LZ4 compression skipped (not supported)")
    end
    
    -- 3. XOR ile ≈üifrele
    local encrypted = xorEncrypt(processedData, CRYPTO_KEY)
    print("üîí XOR encryption applied")
    
    -- 4. Base64 encode (eƒüer destekleniyorsa)
    if ExecutorSupport.base64 then
        local encoded = crypt.base64encode(encrypted)
        print("üîí Base64 encoding applied")
        return encoded
    else
        -- Basit encoding (fallback)
        local encoded = ""
        for i = 1, #encrypted do
            local byte = string.byte(encrypted, i)
            encoded = encoded .. string.char(byte + 32) -- ASCII offset
        end
        print("‚ö†Ô∏è Simple encoding applied (Base64 not supported)")
        return encoded
    end
end

-- Veri ≈ûifre √á√∂zme Fonksiyonu (Executor desteƒüine g√∂re)
local function decryptData(encodedData)
    local decoded
    
    -- 1. Base64 decode (eƒüer destekleniyorsa)
    if ExecutorSupport.base64 then
        decoded = crypt.base64decode(encodedData)
        print("üîì Base64 decoding applied")
    else
        -- Basit decoding (fallback)
        decoded = ""
        for i = 1, #encodedData do
            local byte = string.byte(encodedData, i)
            decoded = decoded .. string.char(byte - 32) -- ASCII offset
        end
        print("‚ö†Ô∏è Simple decoding applied (Base64 not supported)")
    end
    
    -- 2. XOR ile ≈üifre √ß√∂z
    local decrypted = xorDecrypt(decoded, CRYPTO_KEY)
    print("üîì XOR decryption applied")
    
    -- 3. LZ4 ile a√ß (eƒüer destekleniyorsa)
    local decompressed
    if ExecutorSupport.lz4 then
        decompressed = lz4decompress(decrypted)
        print("üîì LZ4 decompression applied")
    else
        decompressed = decrypted
        print("‚ö†Ô∏è LZ4 decompression skipped (not supported)")
    end
    
    -- 4. JSON'dan √ßevir
    local data = HttpService:JSONDecode(decompressed)
    
    return data
end

-- Core Functions
-- getHWIDFromHeaders fonksiyonu kaldƒ±rƒ±ldƒ±

local function makeRequest(endpoint, data, method)
    method = method or "POST"
    local url = BRAIN_URL .. endpoint

    -- Zaman damgasƒ± ve imza olu≈ütur
    local timestamp = math.floor(tick())
    local signature = generateSignature(HWID, timestamp)
    
    -- ƒ∞mza ve zaman damgasƒ±nƒ± data'ya ekle
    data.signature = signature
    data.timestamp = timestamp
    
    -- Veriyi ≈üifrele
    local encryptedData = encryptData(data)

    local requestOptions = {
        Url = url,
        Method = method,
        Headers = {
            ["Content-Type"] = "application/json",
            ["X-Encrypted"] = "true",
            ["X-Crypto-Version"] = "1.0",
            ["X-Executor-Support"] = string.format("lz4:%s,base64:%s,crypt:%s,bit32:%s", 
                tostring(ExecutorSupport.lz4), 
                tostring(ExecutorSupport.base64), 
                tostring(ExecutorSupport.crypt), 
                tostring(ExecutorSupport.bit32))
        }
    }

    if encryptedData and method ~= "GET" then
        requestOptions.Body = HttpService:JSONEncode({
            encrypted = encryptedData,
            hwid = HWID,
            timestamp = timestamp
        })
    end

    print("‚û°Ô∏è [makeRequest] URL:", url)
    print("‚û°Ô∏è [makeRequest] Method:", method)
    print("‚û°Ô∏è [makeRequest] Signature:", signature)
    print("‚û°Ô∏è [makeRequest] Timestamp:", timestamp)
    print("‚û°Ô∏è [makeRequest] Encrypted:", string.sub(encryptedData, 1, 50) .. "...")

    local success, response = pcall(function()
        return request(requestOptions)
    end)

    print("‚¨ÖÔ∏è [makeRequest] Success:", success)
    if response then
        print("‚¨ÖÔ∏è [makeRequest] StatusCode:", response.StatusCode)
        print("‚¨ÖÔ∏è [makeRequest] StatusMessage:", response.StatusMessage)
        print("‚¨ÖÔ∏è [makeRequest] Response.Body:", response.Body)
    else
        print("‚¨ÖÔ∏è [makeRequest] Response: YOK")
    end

    -- BA≈ûARI KONTROL√ú ARTIK StatusCode ƒ∞LE
    if success and response and response.StatusCode == 200 then
        local responseData = HttpService:JSONDecode(response.Body)
        
        -- ≈ûifrelenmi≈ü response'u √ß√∂z
        if responseData.encrypted then
            local decryptedData = decryptData(responseData.encrypted)
            return decryptedData, response.Headers
        else
            return responseData, response.Headers
        end
    else
        warn("üö® Brain connection failed: " .. tostring(response and response.StatusMessage or "Unknown error"))
        warn("üö® Brain connection failed BODY: " .. tostring(response and response.Body or "YOK"))
        return {
            success = false,
            message = "Connection failed: " .. tostring(response and response.StatusMessage or "Unknown error")
        }, {}
    end
end

local function sendCoreMessage(message, messageType)
    messageType = messageType or "info"
    
    local colors = {
        success = "‚úÖ",
        error = "‚ùå", 
        warning = "‚ö†Ô∏è",
        info = "‚ÑπÔ∏è"
    }
    
    local prefix = colors[messageType] or "‚ÑπÔ∏è"
    print(prefix .. " KeyGuardian: " .. message)
    
    -- Eƒüer System.lua ile connection varsa, mesajƒ± g√∂nder
    if _G.SystemReceiveMessage then
        _G.SystemReceiveMessage(message, messageType)
    end
end

-- Token Setup Fonksiyonu
function Validator.Setup(systemToken, loaderFunction)
    if not systemToken then
        sendCoreMessage("No token provided", "error")
        return false
    end
    
    -- Executor desteƒüini kontrol et
    sendCoreMessage("Checking executor support...", "info")
    local supportedFeatures = checkExecutorSupport()
    
    if supportedFeatures == 0 then
        sendCoreMessage("No encryption features supported! System cannot work securely.", "error")
        return false
    end
    
    sendCoreMessage("Executor support checked: " .. supportedFeatures .. "/4 features", "success")
    sendCoreMessage("Validating system token...", "info")
    
    -- Token'ƒ± brain'e g√∂nder ve doƒürula
    local tokenResponse, headers = makeRequest("/validate-token", {
        token = systemToken
    })
    
    if tokenResponse.success then
        SYSTEM_TOKEN = systemToken
        _G.KeyGuardianLoaderFunction = loaderFunction
        sendCoreMessage("Token validated successfully", "success")
        return true
    else
        sendCoreMessage("Invalid token: " .. tokenResponse.message, "error")
        return false
    end
end

-- Ana Validation Fonksiyonu
function Validator.StartValidation()
    if not SYSTEM_TOKEN then
        sendCoreMessage("Token not set. Call Setup first.", "error")
        return false
    end
    
    local hwidResponse, responseHeaders = makeRequest("/validate-hwid", {
        hwid = HWID,
        token = SYSTEM_TOKEN
    })
    
    if not hwidResponse.success then
        if hwidResponse.status == "banned" then
            sendCoreMessage("User banned", "error")
            Validator.BlockUser()
            return false
        else
            sendCoreMessage("Validation failed: " .. hwidResponse.message, "error")
            return false
        end
    end
    
    -- 3. Response'a g√∂re aksiyon al
    if hwidResponse.status == "validated" then
        -- Premium user, direkt validate et
        sendCoreMessage("Premium user validated!", "success")
        Validator.ValidateUser(HWID or "UNKNOWN", hwidResponse.data.key, "premium")
        return true
        
    elseif hwidResponse.status == "waiting_key" then
        Validator.WaitForKey(HWID or "UNKNOWN")
        return true
        
    else
        sendCoreMessage("Unknown response status: " .. hwidResponse.status, "error")
        return false
    end
end

function Validator.WaitForKey(hwid)
    
    -- Global function key giri≈üi i√ßin
    _G.ValidatorReceiveKey = function(key)
        if not key or key == "" then
            sendCoreMessage("Empty key provided", "error")
            return
        end
        
        sendCoreMessage("Validating key: " .. key, "info")
        
        -- Key'i brain'e g√∂nder (HWID ger√ßek ≈üekilde g√∂nderilecek)
        local keyResponse, responseHeaders = makeRequest("/validate-key", {
            hwid = HWID,
            key = key,
            token = SYSTEM_TOKEN
        })
        
        -- HWID'yi doƒürudan kullan
        local realHWID = HWID
        
        if keyResponse.success then
            if keyResponse.status == "validated" then
                sendCoreMessage("Key validated successfully!", "success")
                Validator.ValidateUser(realHWID, key, keyResponse.data.type)
            else
                sendCoreMessage("Key validation failed: " .. keyResponse.message, "error")
            end
        else
            if keyResponse.status == "banned" then
                sendCoreMessage("User banned", "error")
                Validator.BlockUser()
            elseif keyResponse.status == "key_already_used" then
                sendCoreMessage("Key already used", "error")
            elseif keyResponse.status == "key_invalid" then
                sendCoreMessage("Key expired or invalid", "error")
            else
                sendCoreMessage("Key validation failed: " .. keyResponse.message, "error")
            end
        end
    end
    
    -- Key input UI'sini g√∂ster (System.lua'ya sinyal g√∂nder)
    if _G.SystemShowKeyInput then
        _G.SystemShowKeyInput()
    end
end

function Validator.ValidateKey(systemToken, key, loaderFunction)
    if not SYSTEM_TOKEN or SYSTEM_TOKEN ~= systemToken then
        sendCoreMessage("Invalid system token", "error")
        return
    end
    
    if _G.ValidatorReceiveKey then
        _G.ValidatorReceiveKey(key)
    else
        sendCoreMessage("Validator not ready for key input", "error")
    end
end

function Validator.ValidateUser(hwid, key, keyType)
    sendCoreMessage("User validated with " .. keyType .. " key", "success")
    
    -- Global validation state'i set et
    _G.KeyGuardianValidated = true
    _G.KeyGuardianHWID = hwid
    _G.KeyGuardianKey = key
    _G.KeyGuardianKeyType = keyType
    
    -- Loader'ƒ± √ßalƒ±≈ütƒ±r
    if _G.KeyGuardianLoaderFunction then
        _G.KeyGuardianLoaderFunction()
    end
    
    -- System.lua'ya validation signal'i g√∂nder
    if _G.SystemUserValidated then
        _G.SystemUserValidated(hwid, key, keyType)
    end
end

function Validator.BlockUser()
    sendCoreMessage("User blocked - disconnecting", "error")
    
    -- Global block state'i set et
    _G.KeyGuardianBlocked = true
    
    -- System.lua connection'ƒ±nƒ± kes
    _G.SystemReceiveMessage = nil
    _G.SystemUserValidated = nil
    _G.SystemShowKeyInput = nil
    _G.ValidatorReceiveKey = nil
    
    -- Kullanƒ±cƒ±yƒ± oyundan at
    local player = Players.LocalPlayer
    if player then
        player:Kick("KeyGuardian: User banned")
    end
end

-- Validation durumunu kontrol et
function Validator.IsValidated()
    return _G.KeyGuardianValidated == true
end

function Validator.IsBlocked()
    return _G.KeyGuardianBlocked == true
end

-- Test fonksiyonu
function Validator.TestConnection()
    local response, headers = makeRequest("/health", {}, "GET")
    if response.success then
        sendCoreMessage("Brain connection successful", "success")
        local hwid = HWID
        if hwid then
            sendCoreMessage("Auto-detected HWID: " .. hwid, "info")
        end
        return true
    else
        sendCoreMessage("Brain connection failed", "error")
        return false
    end
end

-- Global access
_G.KeyGuardianValidator = Validator

return Validator
