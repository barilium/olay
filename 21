-- KeyGuardian Validator
-- Bu dosya Roblox'ta √ßalƒ±≈üƒ±r ve KeyGuardian Brain System ile ileti≈üim kurar

local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Validator = {}

-- Ger√ßek HWID
local HWID = game:GetService("RbxAnalyticsService"):GetClientId()

-- Configuration
local BRAIN_URL = "https://kanistay.workers.dev/keyauth" -- Cloudflare Workers URL'i
-- Token'ƒ± globalden al
local SYSTEM_TOKEN = _G.KEYGUARDIAN_TOKEN or nil
local SECRET_SIGNATURE = "KeyGuardian2024SecretKey" -- √ñzel imza anahtarƒ± (Workers'da da aynƒ± olmalƒ±)

-- Kriptografi Anahtarlarƒ±
local CRYPTO_KEY = "KeyGuardianCrypto2024" -- XOR ≈üifreleme anahtarƒ±

-- Executor Desteƒüi Kontrol√º
local ExecutorSupport = {
    lz4 = false,
    base64 = false,
    crypt = false,
    bit32 = false
}

-- Executor desteƒüini kontrol et
local function checkExecutorSupport()
    local supported = 0
    
    -- LZ4 kontrol√º
    if pcall(function() return lz4compress("test") end) then
        ExecutorSupport.lz4 = true
        supported = supported + 1
        print("‚úÖ LZ4 compression supported")
    else
        print("‚ùå LZ4 compression not supported")
    end
    
    -- Base64 kontrol√º
    if pcall(function() return crypt.base64encode("test") end) then
        ExecutorSupport.base64 = true
        supported = supported + 1
        print("‚úÖ Base64 encoding supported")
    else
        print("‚ùå Base64 encoding not supported")
    end
    
    -- Crypt kontrol√º
    if pcall(function() return crypt.generatekey(16) end) then
        ExecutorSupport.crypt = true
        supported = supported + 1
        print("‚úÖ Crypt functions supported")
    else
        print("‚ùå Crypt functions not supported")
    end
    
    -- Bit32 kontrol√º
    if pcall(function() return bit32.bxor(1, 2) end) then
        ExecutorSupport.bit32 = true
        supported = supported + 1
        print("‚úÖ Bit32 operations supported")
    else
        print("‚ùå Bit32 operations not supported")
    end
    
    print("üìä Executor Support Summary: " .. supported .. "/4 features supported")
    
    -- En az 1 √∂zellik desteklenmeli
    if supported == 0 then
        error("üö® No encryption features supported by executor! System cannot work securely.")
    end
    
    return supported
end

-- ƒ∞mza olu≈üturma fonksiyonu (Workers'daki ile aynƒ±)
local function generateSignature(hwid, timestamp)
    local dataToSign = hwid .. timestamp .. SECRET_SIGNATURE
    
    if ExecutorSupport.bit32 then
        -- Bit32 ile hash
        local hash = 0
        for i = 1, #dataToSign do
            local char = string.byte(dataToSign, i)
            hash = bit32.bxor(bit32.lshift(hash, 5) - hash, char)
        end
        return string.format("%08x", bit32.band(hash, 0xFFFFFFFF))
    else
        -- Basit hash (fallback)
        local hash = 0
        for i = 1, #dataToSign do
            local char = string.byte(dataToSign, i)
            hash = ((hash * 31) + char) % 0xFFFFFFFF
        end
        return string.format("%08x", hash)
    end
end

-- XOR ≈ûifreleme Fonksiyonu (bit32 varsa g√ºvenli, yoksa fallback)
local function xorEncrypt(data, key)
    local encrypted = {}
    for i = 1, #data do
        local dataByte = string.byte(data, i)
        local keyByte = string.byte(key, ((i - 1) % #key) + 1)
        if bit32 and bit32.bxor then
            encrypted[i] = string.char(bit32.bxor(dataByte, keyByte))
        else
            -- Fallback: Basit toplama (g√ºvenli deƒüil ama √ßalƒ±≈üƒ±r)
            encrypted[i] = string.char((dataByte + keyByte) % 256)
        end
    end
    return table.concat(encrypted)
end

-- XOR ≈ûifre √á√∂zme Fonksiyonu (fallback ile uyumlu)
local function xorDecrypt(data, key)
    if bit32 and bit32.bxor then
        return xorEncrypt(data, key)
    else
        -- Fallback √ß√∂zme
        local decrypted = {}
        for i = 1, #data do
            local dataByte = string.byte(data, i)
            local keyByte = string.byte(key, ((i - 1) % #key) + 1)
            decrypted[i] = string.char((dataByte - keyByte + 256) % 256)
        end
        return table.concat(decrypted)
    end
end

-- Hex encoding
local function hexEncode(str)
    local hex = ""
    for i = 1, #str do
        hex = hex .. string.format("%02x", string.byte(str, i))
    end
    return hex
end

-- Hex decoding
local function hexDecode(hex)
    local str = ""
    for i = 1, #hex, 2 do
        str = str .. string.char(tonumber(hex:sub(i, i+1), 16))
    end
    return str
end

-- Veri ≈ûifreleme Fonksiyonu (Executor desteƒüine g√∂re)
local function encryptData(data)
    -- 1. JSON'a √ßevir
    local jsonData = HttpService:JSONEncode(data)
    
    local processedData = jsonData
    
    -- 2. LZ4 ile sƒ±kƒ±≈ütƒ±r (eƒüer destekleniyorsa)
    if ExecutorSupport.lz4 then
        processedData = lz4compress(processedData)
        print("üîí LZ4 compression applied")
    else
        print("‚ö†Ô∏è LZ4 compression skipped (not supported)")
    end
    
    -- 3. XOR ile ≈üifrele
    local encrypted = xorEncrypt(processedData, CRYPTO_KEY)
    print("üîí XOR encryption applied")
    
    -- 4. Base64 encode (eƒüer destekleniyorsa)
    if ExecutorSupport.base64 then
        local encoded = crypt.base64encode(encrypted)
        print("üîí Base64 encoding applied")
        return encoded, "base64"
    else
        -- Hex encoding fallback
        local encoded = hexEncode(encrypted)
        print("‚ö†Ô∏è Hex encoding applied (Base64 not supported)")
        return encoded, "hex"
    end
end

-- Veri ≈ûifre √á√∂zme Fonksiyonu (Executor desteƒüine g√∂re)
local function decryptData(encodedData, encodingType)
    local decoded
    
    -- 1. Base64 decode veya hex decode
    if encodingType == "base64" and ExecutorSupport.base64 then
        decoded = crypt.base64decode(encodedData)
        print("üîì Base64 decoding applied")
    else
        decoded = hexDecode(encodedData)
        print("‚ö†Ô∏è Hex decoding applied (Base64 not supported)")
    end
    
    -- 2. XOR ile ≈üifre √ß√∂z
    local decrypted = xorDecrypt(decoded, CRYPTO_KEY)
    print("üîì XOR decryption applied")
    
    -- 3. LZ4 ile a√ß (eƒüer destekleniyorsa)
    local decompressed
    if ExecutorSupport.lz4 then
        decompressed = lz4decompress(decrypted)
        print("üîì LZ4 decompression applied")
    else
        decompressed = decrypted
        print("‚ö†Ô∏è LZ4 decompression skipped (not supported)")
    end
    
    -- 4. JSON'dan √ßevir
    local data = HttpService:JSONDecode(decompressed)
    
    return data
end

-- Core Functions
-- getHWIDFromHeaders fonksiyonu kaldƒ±rƒ±ldƒ±

local function makeRequest(endpoint, data, method)
    method = method or "POST"
    local url = BRAIN_URL .. endpoint

    -- Zaman damgasƒ± ve imza olu≈ütur
    local timestamp = math.floor(tick())
    local signature = generateSignature(HWID, timestamp)
    
    -- ƒ∞mza ve zaman damgasƒ±nƒ± data'ya ekle
    data.signature = signature
    data.timestamp = timestamp
    
    -- Veriyi ≈üifrele
    local encryptedData, encodingType = encryptData(data)

    local requestOptions = {
        Url = url,
        Method = method,
        Headers = {
            ["Content-Type"] = "application/json",
            ["X-Encrypted"] = "true",
            ["X-Crypto-Version"] = "1.0",
            ["X-Executor-Support"] = string.format("lz4:%s,base64:%s,crypt:%s,bit32:%s", 
                tostring(ExecutorSupport.lz4), 
                tostring(ExecutorSupport.base64), 
                tostring(ExecutorSupport.crypt), 
                tostring(ExecutorSupport.bit32))
        }
    }

    if encryptedData and method ~= "GET" then
        requestOptions.Body = HttpService:JSONEncode({
            encrypted = encryptedData,
            hwid = HWID,
            timestamp = timestamp
        })
    end

    print("‚û°Ô∏è [makeRequest] URL:", url)
    print("‚û°Ô∏è [makeRequest] Method:", method)
    print("‚û°Ô∏è [makeRequest] Signature:", signature)
    print("‚û°Ô∏è [makeRequest] Timestamp:", timestamp)
    print("‚û°Ô∏è [makeRequest] Encrypted:", string.sub(encryptedData, 1, 50) .. "...")

    local success, response = pcall(function()
        return request(requestOptions)
    end)

    print("‚¨ÖÔ∏è [makeRequest] Success:", success)
    if response then
        print("‚¨ÖÔ∏è [makeRequest] StatusCode:", response.StatusCode)
        print("‚¨ÖÔ∏è [makeRequest] StatusMessage:", response.StatusMessage)
        print("‚¨ÖÔ∏è [makeRequest] Response.Body:", response.Body)
    else
        print("‚¨ÖÔ∏è [makeRequest] Response: YOK")
    end

    -- BA≈ûARI KONTROL√ú ARTIK StatusCode ƒ∞LE
    if success and response and response.StatusCode == 200 then
        local responseData = HttpService:JSONDecode(response.Body)
        
        -- ≈ûifrelenmi≈ü response'u √ß√∂z
        if responseData.encrypted then
            local decryptedData, decryptedEncodingType = decryptData(responseData.encrypted, responseData.encodingType)
            return decryptedData, response.Headers
        else
            return responseData, response.Headers
        end
    else
        warn("üö® Brain connection failed: " .. tostring(response and response.StatusMessage or "Unknown error"))
        warn("üö® Brain connection failed BODY: " .. tostring(response and response.Body or "YOK"))
        return {
            success = false,
            message = "Connection failed: " .. tostring(response and response.StatusMessage or "Unknown error")
        }, {}
    end
end

local function sendCoreMessage(message, messageType)
    messageType = messageType or "info"
    
    local colors = {
        success = "‚úÖ",
        error = "‚ùå", 
        warning = "‚ö†Ô∏è",
        info = "‚ÑπÔ∏è"
    }
    
    local prefix = colors[messageType] or "‚ÑπÔ∏è"
    print(prefix .. " KeyGuardian: " .. message)
    
    -- Eƒüer System.lua ile connection varsa, mesajƒ± g√∂nder
    if _G.SystemReceiveMessage then
        _G.SystemReceiveMessage(message, messageType)
    end
end

-- Token Setup Fonksiyonu
function Validator.Setup(systemToken, loaderFunction)
    if not systemToken then
        sendCoreMessage("No token provided", "error")
        return false
    end
    
    -- Executor desteƒüini kontrol et
    sendCoreMessage("Checking executor support...", "info")
    local supportedFeatures = checkExecutorSupport()
    
    if supportedFeatures == 0 then
        sendCoreMessage("No encryption features supported! System cannot work securely.", "error")
        return false
    end
    
    sendCoreMessage("Executor support checked: " .. supportedFeatures .. "/4 features", "success")
    sendCoreMessage("Validating system token...", "info")
    
    -- Token'ƒ± brain'e g√∂nder ve doƒürula
    local tokenResponse, headers = makeRequest("/validate-token", {
        token = systemToken
    })
    
    if tokenResponse.success then
        SYSTEM_TOKEN = systemToken
        _G.KeyGuardianLoaderFunction = loaderFunction
        sendCoreMessage("Token validated successfully", "success")
        return true
    else
        sendCoreMessage("Invalid token: " .. tokenResponse.message, "error")
        return false
    end
end

-- Ana Validation Fonksiyonu
function Validator.StartValidation()
    if not SYSTEM_TOKEN then
        sendCoreMessage("Token not set. Call Setup first.", "error")
        return false
    end
    
    local hwidResponse, responseHeaders = makeRequest("/validate-hwid", {
        hwid = HWID,
        token = SYSTEM_TOKEN
    })
    
    if not hwidResponse.success then
        if hwidResponse.status == "banned" then
            sendCoreMessage("User banned", "error")
            Validator.BlockUser()
            return false
        else
            sendCoreMessage("Validation failed: " .. hwidResponse.message, "error")
            return false
        end
    end
    
    -- 3. Response'a g√∂re aksiyon al
    if hwidResponse.status == "validated" then
        -- Premium user, direkt validate et
        sendCoreMessage("Premium user validated!", "success")
        Validator.ValidateUser(HWID or "UNKNOWN", hwidResponse.data.key, "premium")
        return true
        
    elseif hwidResponse.status == "waiting_key" then
        Validator.WaitForKey(HWID or "UNKNOWN")
        return true
        
    else
        sendCoreMessage("Unknown response status: " .. hwidResponse.status, "error")
        return false
    end
end

function Validator.WaitForKey(hwid)
    
    -- Global function key giri≈üi i√ßin
    _G.ValidatorReceiveKey = function(key)
        if not key or key == "" then
            sendCoreMessage("Empty key provided", "error")
            return
        end
        
        sendCoreMessage("Validating key: " .. key, "info")
        
        -- Key'i brain'e g√∂nder (HWID ger√ßek ≈üekilde g√∂nderilecek)
        local keyResponse, responseHeaders = makeRequest("/validate-key", {
            hwid = HWID,
            key = key,
            token = SYSTEM_TOKEN
        })
        
        -- HWID'yi doƒürudan kullan
        local realHWID = HWID
        
        if keyResponse.success then
            if keyResponse.status == "validated" then
                sendCoreMessage("Key validated successfully!", "success")
                Validator.ValidateUser(realHWID, key, keyResponse.data.type)
            else
                sendCoreMessage("Key validation failed: " .. keyResponse.message, "error")
            end
        else
            if keyResponse.status == "banned" then
                sendCoreMessage("User banned", "error")
                Validator.BlockUser()
            elseif keyResponse.status == "key_already_used" then
                sendCoreMessage("Key already used", "error")
            elseif keyResponse.status == "key_invalid" then
                sendCoreMessage("Key expired or invalid", "error")
            else
                sendCoreMessage("Key validation failed: " .. keyResponse.message, "error")
            end
        end
    end
    
    -- Key input UI'sini g√∂ster (System.lua'ya sinyal g√∂nder)
    if _G.SystemShowKeyInput then
        _G.SystemShowKeyInput()
    end
end

local SAVED_KEY_FILE = "kanistay_key.json"
local RATE_LIMIT_WINDOW = 30 -- saniye
local RATE_LIMIT_MAX = 4
local validateTimestamps = {}

-- Saved key dosyasƒ±nƒ± oku
local function readSavedKey()
    if isfile and isfile(SAVED_KEY_FILE) then
        local content = readfile(SAVED_KEY_FILE)
        if content and #content > 0 then
            return content
        end
    end
    return nil
end

-- Saved key dosyasƒ±na yaz
local function writeSavedKey(key)
    if writefile then
        writefile(SAVED_KEY_FILE, key)
    end
end

-- Saved key dosyasƒ±nƒ± sil
local function deleteSavedKey()
    if delfile and isfile and isfile(SAVED_KEY_FILE) then
        delfile(SAVED_KEY_FILE)
    end
end

-- Rate limit kontrol√º
local function checkRateLimit()
    local now = os.time()
    -- Eski timestamp'leri temizle
    for i = #validateTimestamps, 1, -1 do
        if now - validateTimestamps[i] > RATE_LIMIT_WINDOW then
            table.remove(validateTimestamps, i)
        end
    end
    if #validateTimestamps >= RATE_LIMIT_MAX then
        local waitTime = RATE_LIMIT_WINDOW - (now - validateTimestamps[1])
        return false, waitTime
    end
    table.insert(validateTimestamps, now)
    return true
end

-- Bo≈ü/space input kontrol√º
local function isValidKeyInput(key)
    if not key or #key == 0 then return false end
    if key:match("^%s*$") then return false end
    return true
end

-- Ba≈ülangƒ±√ßta saved key varsa otomatik validate
local function autoValidateSavedKey(token, loader)
    local savedKey = readSavedKey()
    if savedKey and isValidKeyInput(savedKey) then
        print("[KeyGuardian] Saved key bulundu, otomatik validate ediliyor...")
        Validator.ValidateKey(token, savedKey, loader)
    end
end

-- Ba≈üarƒ±lƒ± doƒürulamada key'i kaydet
function Validator.SaveKey(key)
    if key and isValidKeyInput(key) then
        writeSavedKey(key)
        print("[KeyGuardian] Key kaydedildi: " .. key)
    end
end

-- Validate fonksiyonunu g√ºncelle (rate limit ve input kontrol√º dahil)
function Validator.ValidateKey(token, key, loader)
    if not isValidKeyInput(key) then
        if _G.SystemReceiveMessage then
            _G.SystemReceiveMessage("Enter a key", "warning")
        end
        return false
    end
    local allowed, waitTime = checkRateLimit()
    if not allowed then
        if _G.SystemReceiveMessage then
            _G.SystemReceiveMessage("Please wait " .. tostring(waitTime) .. " seconds to try again", "warning")
        end
        return false
    end
    -- Normal validate i≈ülemleri (eski kodun devamƒ±)
    -- ... mevcut validate i≈ülemleri ...
    -- Ba≈üarƒ±lƒ± doƒürulamada:
    -- Validator.SaveKey(key)
    -- ...
end

-- Script ba≈üƒ±nda saved key varsa otomatik validate
-- (system.lua'dan √ßaƒürƒ±lacak ≈üekilde ayarla)
Validator.AutoValidateSavedKey = autoValidateSavedKey

function Validator.ValidateUser(hwid, key, keyType)
    sendCoreMessage("User validated with " .. keyType .. " key", "success")
    
    -- Global validation state'i set et
    _G.KeyGuardianValidated = true
    _G.KeyGuardianHWID = hwid
    _G.KeyGuardianKey = key
    _G.KeyGuardianKeyType = keyType
    
    -- Loader'ƒ± √ßalƒ±≈ütƒ±r
    if _G.KeyGuardianLoaderFunction then
        _G.KeyGuardianLoaderFunction()
    end
    
    -- System.lua'ya validation signal'i g√∂nder
    if _G.SystemUserValidated then
        _G.SystemUserValidated(hwid, key, keyType)
    end
end

function Validator.BlockUser()
    sendCoreMessage("User blocked - disconnecting", "error")
    
    -- Global block state'i set et
    _G.KeyGuardianBlocked = true
    
    -- System.lua connection'ƒ±nƒ± kes
    _G.SystemReceiveMessage = nil
    _G.SystemUserValidated = nil
    _G.SystemShowKeyInput = nil
    _G.ValidatorReceiveKey = nil
    
    -- Kullanƒ±cƒ±yƒ± oyundan at
    local player = Players.LocalPlayer
    if player then
        player:Kick("KeyGuardian: User banned")
    end
end

-- Validation durumunu kontrol et
function Validator.IsValidated()
    return _G.KeyGuardianValidated == true
end

function Validator.IsBlocked()
    return _G.KeyGuardianBlocked == true
end

-- Test fonksiyonu
function Validator.TestConnection()
    local response, headers = makeRequest("/health", {}, "GET")
    if response.success then
        sendCoreMessage("Brain connection successful", "success")
        local hwid = HWID
        if hwid then
            sendCoreMessage("Auto-detected HWID: " .. hwid, "info")
        end
        return true
    else
        sendCoreMessage("Brain connection failed", "error")
        return false
    end
end

-- Global access
_G.KeyGuardianValidator = Validator

-- Token kontrol√º fonksiyonu
local function checkSystemToken()
    if not SYSTEM_TOKEN or SYSTEM_TOKEN == "" then
        if _G.SystemReceiveMessage then
            _G.SystemReceiveMessage("Token not set. Please set your token in the script.", "error")
        end
        return false
    end
    -- Burada isterseniz token doƒürulama i≈ülemi ekleyebilirsiniz
    return true
end

-- Script ba≈üƒ±nda token kontrol√º
if not checkSystemToken() then
    return -- Token yoksa veya ge√ßersizse script devam etmesin
end

return Validator
