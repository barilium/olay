-- KeyGuardian Validator
-- Bu dosya Roblox'ta Ã§alÄ±ÅŸÄ±r ve KeyGuardian Brain System ile iletiÅŸim kurar

local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Validator = {}

-- GerÃ§ek HWID
local HWID = game:GetService("RbxAnalyticsService"):GetClientId()

-- Configuration
local BRAIN_URL = "https://kanistay.workers.dev/keyauth" -- Cloudflare Workers URL'i
-- Token'Ä± globalden al
local SYSTEM_TOKEN = _G.KEYGUARDIAN_TOKEN or nil
local SECRET_SIGNATURE = "KeyGuardian2024SecretKey" -- Ã–zel imza anahtarÄ± (Workers'da da aynÄ± olmalÄ±)

-- Kriptografi AnahtarlarÄ±
local CRYPTO_KEY = "KeyGuardianCrypto2024" -- XOR ÅŸifreleme anahtarÄ±

-- Executor DesteÄŸi KontrolÃ¼
local ExecutorSupport = {
    lz4 = false,
    base64 = false,
    crypt = false,
    bit32 = false
}

-- Executor desteÄŸini kontrol et
local function checkExecutorSupport()
    local supported = 0
    
    -- LZ4 kontrolÃ¼
    if pcall(function() return lz4compress("test") end) then
        ExecutorSupport.lz4 = true
        supported = supported + 1
        print("âœ… LZ4 compression supported")
    else
        print("âŒ LZ4 compression not supported")
    end
    
    -- Base64 kontrolÃ¼
    if pcall(function() return crypt.base64encode("test") end) then
        ExecutorSupport.base64 = true
        supported = supported + 1
        print("âœ… Base64 encoding supported")
    else
        print("âŒ Base64 encoding not supported")
    end
    
    -- Crypt kontrolÃ¼
    if pcall(function() return crypt.generatekey(16) end) then
        ExecutorSupport.crypt = true
        supported = supported + 1
        print("âœ… Crypt functions supported")
    else
        print("âŒ Crypt functions not supported")
    end
    
    -- Bit32 kontrolÃ¼
    if pcall(function() return bit32.bxor(1, 2) end) then
        ExecutorSupport.bit32 = true
        supported = supported + 1
        print("âœ… Bit32 operations supported")
    else
        print("âŒ Bit32 operations not supported")
    end
    
    print("ğŸ“Š Executor Support Summary: " .. supported .. "/4 features supported")
    
    -- En az 1 Ã¶zellik desteklenmeli
    if supported == 0 then
        error("ğŸš¨ No encryption features supported by executor! System cannot work securely.")
    end
    
    return supported
end

-- Ä°mza oluÅŸturma fonksiyonu (Workers'daki ile aynÄ±)
local function generateSignature(hwid, timestamp)
    local dataToSign = hwid .. timestamp .. SECRET_SIGNATURE
    
    if ExecutorSupport.bit32 then
        -- Bit32 ile hash
        local hash = 0
        for i = 1, #dataToSign do
            local char = string.byte(dataToSign, i)
            hash = bit32.bxor(bit32.lshift(hash, 5) - hash, char)
        end
        return string.format("%08x", bit32.band(hash, 0xFFFFFFFF))
    else
        -- Basit hash (fallback)
        local hash = 0
        for i = 1, #dataToSign do
            local char = string.byte(dataToSign, i)
            hash = ((hash * 31) + char) % 0xFFFFFFFF
        end
        return string.format("%08x", hash)
    end
end

-- XOR Åifreleme Fonksiyonu (bit32 varsa gÃ¼venli, yoksa fallback)
local function xorEncrypt(data, key)
    local encrypted = {}
    for i = 1, #data do
        local dataByte = string.byte(data, i)
        local keyByte = string.byte(key, ((i - 1) % #key) + 1)
        if bit32 and bit32.bxor then
            encrypted[i] = string.char(bit32.bxor(dataByte, keyByte))
        else
            -- Fallback: Basit toplama (gÃ¼venli deÄŸil ama Ã§alÄ±ÅŸÄ±r)
            encrypted[i] = string.char((dataByte + keyByte) % 256)
        end
    end
    return table.concat(encrypted)
end

-- XOR Åifre Ã‡Ã¶zme Fonksiyonu (fallback ile uyumlu)
local function xorDecrypt(data, key)
    if bit32 and bit32.bxor then
        return xorEncrypt(data, key)
    else
        -- Fallback Ã§Ã¶zme
        local decrypted = {}
        for i = 1, #data do
            local dataByte = string.byte(data, i)
            local keyByte = string.byte(key, ((i - 1) % #key) + 1)
            decrypted[i] = string.char((dataByte - keyByte + 256) % 256)
        end
        return table.concat(decrypted)
    end
end

-- Hex encoding
local function hexEncode(str)
    local hex = ""
    for i = 1, #str do
        hex = hex .. string.format("%02x", string.byte(str, i))
    end
    return hex
end

-- Hex decoding
local function hexDecode(hex)
    local str = ""
    for i = 1, #hex, 2 do
        str = str .. string.char(tonumber(hex:sub(i, i+1), 16))
    end
    return str
end

-- Veri Åifreleme Fonksiyonu (Executor desteÄŸine gÃ¶re)
local function encryptData(data)
    -- 1. JSON'a Ã§evir
    local jsonData = HttpService:JSONEncode(data)
    
    local processedData = jsonData
    
    -- 2. LZ4 ile sÄ±kÄ±ÅŸtÄ±r (eÄŸer destekleniyorsa)
    if ExecutorSupport.lz4 then
        processedData = lz4compress(processedData)
        print("ğŸ”’ LZ4 compression applied")
    else
        print("âš ï¸ LZ4 compression skipped (not supported)")
    end
    
    -- 3. XOR ile ÅŸifrele
    local encrypted = xorEncrypt(processedData, CRYPTO_KEY)
    print("ğŸ”’ XOR encryption applied")
    
    -- 4. Base64 encode (eÄŸer destekleniyorsa)
    if ExecutorSupport.base64 then
        local encoded = crypt.base64encode(encrypted)
        print("ğŸ”’ Base64 encoding applied")
        return encoded, "base64"
    else
        -- Hex encoding fallback
        local encoded = hexEncode(encrypted)
        print("âš ï¸ Hex encoding applied (Base64 not supported)")
        return encoded, "hex"
    end
end

-- Veri Åifre Ã‡Ã¶zme Fonksiyonu (Executor desteÄŸine gÃ¶re)
local function decryptData(encodedData, encodingType)
    local decoded
    
    -- 1. Base64 decode veya hex decode
    if encodingType == "base64" and ExecutorSupport.base64 then
        decoded = crypt.base64decode(encodedData)
        print("ğŸ”“ Base64 decoding applied")
    else
        decoded = hexDecode(encodedData)
        print("âš ï¸ Hex decoding applied (Base64 not supported)")
    end
    
    -- 2. XOR ile ÅŸifre Ã§Ã¶z
    local decrypted = xorDecrypt(decoded, CRYPTO_KEY)
    print("ğŸ”“ XOR decryption applied")
    
    -- 3. LZ4 ile aÃ§ (eÄŸer destekleniyorsa)
    local decompressed
    if ExecutorSupport.lz4 then
        decompressed = lz4decompress(decrypted)
        print("ğŸ”“ LZ4 decompression applied")
    else
        decompressed = decrypted
        print("âš ï¸ LZ4 decompression skipped (not supported)")
    end
    
    -- 4. JSON'dan Ã§evir
    local data = HttpService:JSONDecode(decompressed)
    
    return data
end

-- Core Functions
-- getHWIDFromHeaders fonksiyonu kaldÄ±rÄ±ldÄ±

local function makeRequest(endpoint, data, method)
    method = method or "POST"
    local url = BRAIN_URL .. endpoint

    -- Zaman damgasÄ± ve imza oluÅŸtur
    local timestamp = math.floor(tick())
    local signature = generateSignature(HWID, timestamp)
    
    -- Ä°mza ve zaman damgasÄ±nÄ± data'ya ekle
    data.signature = signature
    data.timestamp = timestamp
    
    -- Veriyi ÅŸifrele
    local encryptedData, encodingType = encryptData(data)

    local requestOptions = {
        Url = url,
        Method = method,
        Headers = {
            ["Content-Type"] = "application/json",
            ["X-Encrypted"] = "true",
            ["X-Crypto-Version"] = "1.0",
            ["X-Executor-Support"] = string.format("lz4:%s,base64:%s,crypt:%s,bit32:%s", 
                tostring(ExecutorSupport.lz4), 
                tostring(ExecutorSupport.base64), 
                tostring(ExecutorSupport.crypt), 
                tostring(ExecutorSupport.bit32))
        }
    }

    if encryptedData and method ~= "GET" then
        requestOptions.Body = HttpService:JSONEncode({
            encrypted = encryptedData,
            hwid = HWID,
            timestamp = timestamp
        })
    end

    print("â¡ï¸ [makeRequest] URL:", url)
    print("â¡ï¸ [makeRequest] Method:", method)
    print("â¡ï¸ [makeRequest] Signature:", signature)
    print("â¡ï¸ [makeRequest] Timestamp:", timestamp)
    print("â¡ï¸ [makeRequest] Encrypted:", string.sub(encryptedData, 1, 50) .. "...")

    local success, response = pcall(function()
        return request(requestOptions)
    end)

    print("â¬…ï¸ [makeRequest] Success:", success)
    if response then
        print("â¬…ï¸ [makeRequest] StatusCode:", response.StatusCode)
        print("â¬…ï¸ [makeRequest] StatusMessage:", response.StatusMessage)
        print("â¬…ï¸ [makeRequest] Response.Body:", response.Body)
    else
        print("â¬…ï¸ [makeRequest] Response: YOK")
    end

    -- BAÅARI KONTROLÃœ ARTIK StatusCode Ä°LE
    if success and response and response.StatusCode == 200 then
        local responseData = HttpService:JSONDecode(response.Body)
        
        -- ÅifrelenmiÅŸ response'u Ã§Ã¶z
        if responseData.encrypted then
            local decryptedData, decryptedEncodingType = decryptData(responseData.encrypted, responseData.encodingType)
            return decryptedData, response.Headers
        else
            return responseData, response.Headers
        end
    else
        warn("ğŸš¨ Brain connection failed: " .. tostring(response and response.StatusMessage or "Unknown error"))
        warn("ğŸš¨ Brain connection failed BODY: " .. tostring(response and response.Body or "YOK"))
        return {
            success = false,
            message = "Connection failed: " .. tostring(response and response.StatusMessage or "Unknown error")
        }, {}
    end
end

local function sendCoreMessage(message, messageType)
    messageType = messageType or "info"
    
    local colors = {
        success = "âœ…",
        error = "âŒ", 
        warning = "âš ï¸",
        info = "â„¹ï¸"
    }
    
    local prefix = colors[messageType] or "â„¹ï¸"
    print(prefix .. " KeyGuardian: " .. message)
    
    -- EÄŸer System.lua ile connection varsa, mesajÄ± gÃ¶nder
    if _G.SystemReceiveMessage then
        _G.SystemReceiveMessage(message, messageType)
    end
end

-- Token Setup Fonksiyonu
function Validator.Setup(systemToken, loaderFunction)
    if not systemToken then
        sendCoreMessage("No token provided", "error")
        return false
    end
    
    -- Executor desteÄŸini kontrol et
    sendCoreMessage("Checking executor support...", "info")
    local supportedFeatures = checkExecutorSupport()
    
    if supportedFeatures == 0 then
        sendCoreMessage("No encryption features supported! System cannot work securely.", "error")
        return false
    end
    
    sendCoreMessage("Executor support checked: " .. supportedFeatures .. "/4 features", "success")
    sendCoreMessage("Validating system token...", "info")
    
    -- Token'Ä± brain'e gÃ¶nder ve doÄŸrula
    local tokenResponse, headers = makeRequest("/validate-token", {
        token = systemToken
    })
    
    if tokenResponse.success then
        SYSTEM_TOKEN = systemToken
        _G.KeyGuardianLoaderFunction = loaderFunction
        sendCoreMessage("Token validated successfully", "success")
        return true
    else
        sendCoreMessage("Invalid token: " .. tokenResponse.message, "error")
        return false
    end
end

-- Ana Validation Fonksiyonu
function Validator.StartValidation()
    if not SYSTEM_TOKEN then
        sendCoreMessage("Token not set. Call Setup first.", "error")
        return false
    end
    
    local hwidResponse, responseHeaders = makeRequest("/validate-hwid", {
        hwid = HWID,
        token = SYSTEM_TOKEN
    })
    
    if not hwidResponse.success then
        if hwidResponse.status == "banned" then
            sendCoreMessage("User banned", "error")
            Validator.BlockUser()
            return false
        else
            sendCoreMessage("Validation failed: " .. hwidResponse.message, "error")
            return false
        end
    end
    
    -- 3. Response'a gÃ¶re aksiyon al
    if hwidResponse.status == "validated" then
        -- Premium user, direkt validate et
        sendCoreMessage("Premium user validated!", "success")
        Validator.ValidateUser(HWID or "UNKNOWN", hwidResponse.data.key, "premium")
        return true
        
    elseif hwidResponse.status == "waiting_key" then
        Validator.WaitForKey(HWID or "UNKNOWN")
        return true
        
    else
        sendCoreMessage("Unknown response status: " .. hwidResponse.status, "error")
        return false
    end
end

function Validator.WaitForKey(hwid)
    
    -- Global function key giriÅŸi iÃ§in
    _G.ValidatorReceiveKey = function(key)
        if not key or key == "" then
            sendCoreMessage("Empty key provided", "error")
            return
        end
        
        sendCoreMessage("Validating key: " .. key, "info")
        
        -- Key'i brain'e gÃ¶nder (HWID gerÃ§ek ÅŸekilde gÃ¶nderilecek)
        local keyResponse, responseHeaders = makeRequest("/validate-key", {
            hwid = HWID,
            key = key,
            token = SYSTEM_TOKEN
        })
        
        -- HWID'yi doÄŸrudan kullan
        local realHWID = HWID
        
        if keyResponse.success then
            if keyResponse.status == "validated" then
                sendCoreMessage("Key validated successfully!", "success")
                Validator.ValidateUser(realHWID, key, keyResponse.data.type)
            else
                sendCoreMessage("Key validation failed: " .. keyResponse.message, "error")
            end
        else
            if keyResponse.status == "banned" then
                sendCoreMessage("User banned", "error")
                Validator.BlockUser()
            elseif keyResponse.status == "key_already_used" then
                sendCoreMessage("Key already used", "error")
            elseif keyResponse.status == "key_invalid" then
                sendCoreMessage("Key expired or invalid", "error")
            else
                sendCoreMessage("Key validation failed: " .. keyResponse.message, "error")
            end
        end
    end
    
    -- Key input UI'sini gÃ¶ster (System.lua'ya sinyal gÃ¶nder)
    if _G.SystemShowKeyInput then
        _G.SystemShowKeyInput()
    end
end

local SAVED_KEY_FILE = "kanistay_key.json"
local RATE_LIMIT_WINDOW = 30 -- saniye
local RATE_LIMIT_MAX = 4
local validateTimestamps = {}

-- Saved key dosyasÄ±nÄ± oku
local function readSavedKey()
    if isfile and isfile(SAVED_KEY_FILE) then
        local content = readfile(SAVED_KEY_FILE)
        if content and #content > 0 then
            return content
        end
    end
    return nil
end

-- Saved key dosyasÄ±na yaz
local function writeSavedKey(key)
    if writefile then
        writefile(SAVED_KEY_FILE, key)
    end
end

-- Saved key dosyasÄ±nÄ± sil
local function deleteSavedKey()
    if delfile and isfile and isfile(SAVED_KEY_FILE) then
        delfile(SAVED_KEY_FILE)
    end
end

-- Rate limit kontrolÃ¼
local function checkRateLimit()
    local now = os.time()
    -- Eski timestamp'leri temizle
    for i = #validateTimestamps, 1, -1 do
        if now - validateTimestamps[i] > RATE_LIMIT_WINDOW then
            table.remove(validateTimestamps, i)
        end
    end
    if #validateTimestamps >= RATE_LIMIT_MAX then
        local waitTime = RATE_LIMIT_WINDOW - (now - validateTimestamps[1])
        return false, waitTime
    end
    table.insert(validateTimestamps, now)
    return true
end

-- BoÅŸ/space input kontrolÃ¼
local function isValidKeyInput(key)
    if not key or #key == 0 then return false end
    if key:match("^%s*$") then return false end
    return true
end

-- BaÅŸlangÄ±Ã§ta saved key varsa otomatik validate
local function autoValidateSavedKey(token, loader)
    local savedKey = readSavedKey()
    if savedKey and isValidKeyInput(savedKey) then
        print("[KeyGuardian] Saved key bulundu, otomatik validate ediliyor...")
        Validator.ValidateKey(token, savedKey, loader)
    end
end

-- BaÅŸarÄ±lÄ± doÄŸrulamada key'i kaydet
function Validator.SaveKey(key)
    if key and isValidKeyInput(key) then
        writeSavedKey(key)
        print("[KeyGuardian] Key kaydedildi: " .. key)
    end
end

-- Validate fonksiyonunu gÃ¼ncelle (rate limit ve input kontrolÃ¼ dahil)
function Validator.ValidateKey(token, key, loader)
    if not isValidKeyInput(key) then
        if _G.SystemReceiveMessage then
            _G.SystemReceiveMessage("Enter a key", "warning")
        end
        return false
    end
    local allowed, waitTime = checkRateLimit()
    if not allowed then
        if _G.SystemReceiveMessage then
            _G.SystemReceiveMessage("Please wait " .. tostring(waitTime) .. " seconds to try again", "warning")
        end
        return false
    end
    -- Normal validate iÅŸlemleri (eski kodun devamÄ±)
    -- ... mevcut validate iÅŸlemleri ...
    -- BaÅŸarÄ±lÄ± doÄŸrulamada:
    -- Validator.SaveKey(key)
    -- ...
end

-- Script baÅŸÄ±nda saved key varsa otomatik validate
-- (system.lua'dan Ã§aÄŸrÄ±lacak ÅŸekilde ayarla)
Validator.AutoValidateSavedKey = autoValidateSavedKey

function Validator.ValidateUser(hwid, key, keyType)
    sendCoreMessage("User validated with " .. keyType .. " key", "success")
    
    -- Global validation state'i set et
    _G.KeyGuardianValidated = true
    _G.KeyGuardianHWID = hwid
    _G.KeyGuardianKey = key
    _G.KeyGuardianKeyType = keyType
    
    -- Loader'Ä± Ã§alÄ±ÅŸtÄ±r
    if _G.KeyGuardianLoaderFunction then
        _G.KeyGuardianLoaderFunction()
    end
    
    -- System.lua'ya validation signal'i gÃ¶nder
    if _G.SystemUserValidated then
        _G.SystemUserValidated(hwid, key, keyType)
    end
end

function Validator.BlockUser()
    sendCoreMessage("User blocked - disconnecting", "error")
    
    -- Global block state'i set et
    _G.KeyGuardianBlocked = true
    
    -- System.lua connection'Ä±nÄ± kes
    _G.SystemReceiveMessage = nil
    _G.SystemUserValidated = nil
    _G.SystemShowKeyInput = nil
    _G.ValidatorReceiveKey = nil
    
    -- KullanÄ±cÄ±yÄ± oyundan at
    local player = Players.LocalPlayer
    if player then
        player:Kick("KeyGuardian: User banned")
    end
end

-- Validation durumunu kontrol et
function Validator.IsValidated()
    return _G.KeyGuardianValidated == true
end

function Validator.IsBlocked()
    return _G.KeyGuardianBlocked == true
end

-- Test fonksiyonu
function Validator.TestConnection()
    local response, headers = makeRequest("/health", {}, "GET")
    if response.success then
        sendCoreMessage("Brain connection successful", "success")
        local hwid = HWID
        if hwid then
            sendCoreMessage("Auto-detected HWID: " .. hwid, "info")
        end
        return true
    else
        sendCoreMessage("Brain connection failed", "error")
        return false
    end
end

-- Global access
_G.KeyGuardianValidator = Validator

-- Token kontrolÃ¼ fonksiyonu
local function checkSystemToken()
    if not SYSTEM_TOKEN or SYSTEM_TOKEN == "" then
        if _G.SystemReceiveMessage then
            _G.SystemReceiveMessage("Token not set. Please set your token in the script.", "error")
        end
        return false
    end
    -- Burada isterseniz token doÄŸrulama iÅŸlemi ekleyebilirsiniz
    return true
end

-- Script baÅŸÄ±nda token kontrolÃ¼
if not checkSystemToken() then
    return -- Token yoksa veya geÃ§ersizse script devam etmesin
end

return Validator
